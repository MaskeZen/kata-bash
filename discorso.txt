# Introduzione

In realtà ho preparato una cosa che si chiama "slides". È un file di testo dove
c'è scritto cosa faremo, si chiama slides.txt.

    $ ls slides.txt
    $ wc -l slides.txt
    27 slides.txt
    
Contiene 27 slides, però non posso farvele vedere con Powerpoint o con Keynote,
sarebbe contro le regole. Quindi quello che farò e farvi vedere si può costruire
in bash un piccolo sistema per vedere le slide.

Uso mapfile che è un feature nuova di Bash 4, se usate Linux avete la Bash 4, se
usate Mac non c'è e dovete installarla con brew.

    $ mapfile slides <slides.txt

In questo modo abbiamo caricato il contenuto del file slides.txt dentro un array
nella Bash. La Bash ha anche gli array. Per esempio possiamo vedere la prima
slide:

    $ echo ${slides[0]}

Adesso è un attimo creare un sistema che fa vedere le slide ecco:

    $ for slide in "${slides[@]}"; do dialog --msgbox "$slide" 0 0; done

# Demo

Reset prima di iniziare: 

    $ git rm -r bin script && git commit -m "Reset"

Cosa vogliamo ottenere? Un programma da chiamre in questo modo:

    $ bin/add

Che quando viene chiamato restituisce un numero che rappresenta la somma dello
string calculator. Per esempio se lo chiamo con una sfilza di numeri separati da
virgola:

    $ bin/add "1,2,3"

mi deve dare la somma, in questo caso "6". Adesso non da niente, perché il
programma non c'è ancora:


    $ bin/add "1,2,3"
    6

Riassumendo, se lo chiamo così cosa deve restituire?

    $ bin/add "1,2"

E se lo chiamo così?

    $ bin/add "4"

E se lo chiamo così?

    $ bin/add ""

Per riuscire a creare questo comando usiamo il Test-Driven Development e quindi
partiamo dal test.

Io vorrei avere una suite di test da chiamare così:

    $ script/test-all

Vorrei che quando la chiamo così mi segnali se tutti i test passano, oppure se
almeno uno fallisce.

Se provo a chiamarlo ora cosa mi da?

    $ script/test-all
    bash: script/test-all: No such file or directory

Bene questo è il primo test rosso da far passare. La regola del TDD è che quando
sei in barra rossa devi progredire, se sei capace passando alla barra verde,
oppure, se non riesci ad arrivare subito al verde, puoi anche passare da barra
rossa a barra rossa a patto che il messaggio di errore cambi segnando un
progresso. Io dico che "si cambia gradazione di rosso".

In questo caso non si può passare da rosso a verde, però si può cambiare la
gradazione di rosso.

    $ mkdir script
    $ touch script/test-all
    $ script/test-all
    bash: script/test-all: Permission denied

Adesso il file esiste, solo che non è eseguibile, ci vuole poco per risolvere,
basta un `chmod`:

    $ chmod +x script/test-all
    $ script/test-all

Questa è la prima barra verde, in UNIX si usa che quando il programma ha
successo esce con exit code uguale a 0:

    $ echo "$?"
    0

Con la notazione "$?" si stampa l'exit code che è 0, in genere, i comandi UNIX
sono silenziosi se le cose vanno bene o se non ci sono informazioni importanti
da dare. Per il nostro micro sistema di testing possiamo fare che se non scrive
niente e l'exit code è 0 vuol dire che tutti i test sono passati. Quindi, adesso
che non ci sono ancora test ma il comando si può lanciare possiamo dire di
essere in barra verde.

Ora lo apriamo e cominciamo a modificarlo.

    $ vim script/test-all

Prima di scrivere qualche test vorrei rendere possibile lanciare i test 
direttamente da Vim.

Con Vim è facile lanciare i comandi della shell:

    :!script/test-all

Quando lanciamo lo script mostra il terminale con l'eventuale output dello
script, e eventualmente segnala l'exit code (se diverso da 0).

Se i test passano ci fa vedere qualcosa del tipo:

    Press ENTER or type command to continue

Se invece i test non passano ci fa vedere che l'exit code non è 0:
    
    shell returned 1

    Press ENTER or type command to continue
    
Per simulare che un test fallisce usiamo il comando `false`, il comando false è
un built-in particolare della Bash, che non fa niente ma lo fa fallendo, cioè
con un exit code diverso da 0.

    false

Per ritornare ad uno stato in cui si passa possiamo usare il comando duale: 
true. Il comando true ha sempre successo, cioè termina sempre con exit code
uguale a 0.

Non è bella da vedere come barra verde, la voglio migliorare un po'. Come prima
cosa aggiungo il comando clear alla shell, di modo che mi pulisca lo schermo.

    :!clear; script/test-all
    
Poi voglio automatizzare il fatto di lanciare i test. Definisco uno shortcut.

    :nnoremap ,, :wa \| !clear; script/test-all<CR>

Nella definizione dello shortcut ho aggiunto anche il salvataggio automatico dei
file aperti prima di eseguire i test.

Quindi ora appena faccio

    ,,

Mi lancia i test. Ora dovrebbe essere più semplice riconoscere la barra rossa da
quella verde.

Ora cominciamo con il primo test:

    #!/bin/bash

    add "2" > actual_output.txt
    cat > expected_output.txt << EOF
    2
    EOF

    diff expected_output.txt actual_output.txt 

Per risolverlo:

 - Command not found -> aggiungere add()
 - diff trova differenze -> aggiungere echo "2" in add()

    add() {
        echo "2"
    }

# Primo Refactoring

Quali sono i refactoring che si possono fare?

Estrazione di assert-equal:

    assert-equal() {
        local exptected_output="$1"; shift
        local actual_output="$1"
        diff <(echo "$exptected_output") <(echo "$actual_output")
    }

    assert-equal "2" "$(add "2")"

Verifica che assert-equal funziona con altri parametri:

    assert-equal "2" "$(add "2")"
    assert-equal "3" "3"

# Barra rossa o verde

    print-red-or-green-bar() {
        exit_code="$?"
        if [[ "$exit_code" != 0 ]]
        then
            echo "$(tput setaf 1)FAIL$(tput sgr0)"
        else
            echo "$(tput setaf 2)PASS$(tput sgr0)"
        fi
    
        return "$exit_code"
    }



todo list

 - usare una todo list dall'inizio
 - assert-equal
 - messaggio FAIL PASS
 - messaggio FAIL/PASS colorato
 - 

# green bar on exit 
trap print_red_or_green_bar EXIT
print_red_or_green_bar() {
    if [[ "$?" == 0 ]]
    then
        echo "$(tput setaf 2)PASS$(tput sgr0)"
    else
        echo "$(tput setaf 1)FAIL$(tput sgr0)"
    fi
}

# la sberla
script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# print stack trace in bash
print_stack_trace() {
    echo "Stack trace:"
    for (( i=1; i<${#FUNCNAME[@]}; i++)); do
        echo " ${FUNCNAME[$i]}(${BASH_SOURCE[$i]}:${BASH_LINENO[$i-1]})"
    done
} 

# run main function only when the script it's executed, not when it is scripted

    [[ "${BASH_SOURCE[0]}" == "$0" ]] && main "$@"

# green and red

echo "$(tput setaf 2)green$(tput sgr0)"
echo "$(tput setaf 1)red  $(tput sgr0)"

# greenbar
greenbar_on_command() {
    command="$1"
    "$command"
    exit_code="$?"
    if [[ "$exit_code" == 0 ]]
    then
        echo "$(tput setaf 2)"'PASSED'"$(tput sgr0)"
    else
        echo "$(tput setaf 1)"'FAILED'"$(tput sgr0)"
    fi
}

# Echo to stderr

>&2 echo "Failed at line: ${BASH_LINENO[0]}"

# Splitting di una stringa:

IFS=, read -ra array_with_values <<< "$string_of_comma_separated_values" 

# Scrivere una stringa centrata

display_center(){
    line="$1"
    columns="$(tput cols)"
    printf "%*s\n" $(( (${#line} + columns) / 2)) "$line"
}

-eof
